\section{Python Implementation with Example}
The team proposes this Petri net as an example for our Python implementation:
\begin{figure}[H]
    \centering
    \includegraphics[scale = 0.8]{picture/initpetri.png}
    \caption{Example of Petri net}
\end{figure}
In addition, the libraries that are used in our source are:
\begin{itemize}
    \item \code{PyEDA} version 0.28.0 for Binary Decision Diagram task.
    \item \code{NumPy} version 1.24.4 for vector and matrix calculation.
    \item \code{.Petrinet} for handling Petri net from \code{.pnml} file.
\end{itemize}
\subsection{Task 1 - Reading Petri nets from PNML files}

The Petri net class is defined in Python as follows:
\begin{lstlisting}
class PetriNet:
    # Identifier for places and transitions
    self.place_ids = place_ids 
    self.trans_ids = trans_ids
    # Labels for places and transititons
    self.place_names = place_names 
    self.trans_names = trans_names
    self.I = I # Input matrix of size T x P
    self.O = O # Output matrix same size of input matrix
    self.M0 = M0 # Initial marking
    # Class method is defined elsewhere in the source code
\end{lstlisting}

In order to read a Petri net from a \code{.pnml} file, we define a function that can:
\begin{enumerate}
    \item \textbf{XML Parsing}: Uses \code{xml.etree.ElementTree} to parse the file. It includes
    a \code{get\_tag} helper function to ignoring namespaces commonly found in PNML files.
    \item \textbf{Raw Data Extraction:} Iterates to find:
        \begin{itemize}
            \item \code{place}: Extracts ID, Name, and \code{initialMarking} (initial token count).
            \item \code{transition}: Extracts ID and Name.
            \item \code{arc:} Extracts source and target to define connections.
        \end{itemize}
    then mapping IDs to indices. This is essential for populating the \code{numpy} matrices.
    \item \textbf{Matrix Construction:} Initializes matrices with zeros. The matrices are designed with dimensions
     Transitions $\times$ Places ($T \times P$). Then the function iterates through the list of arcs:
        \begin{itemize}
            \item If the arc goes from \textbf{Place $\to$ Transition}: Adds to the \textbf{Input Matrix ($I$)}.
            \item If the arc goes from \textbf{Transition $\to$ Place}: Adds to the \textbf{Output Matrix ($O$)}.
        \end{itemize}
\end{enumerate}
Finally, the function returns an instance of the \code{PetriNet} class with fully processed data.

\begin{figure}[H]
    \centering
    \includegraphics[scale = 0.7]{picture/petrinet.jpg}
    \caption{Reading Petri net from \code{.pnml} file}
\end{figure}

\subsection{Task 2 - Explicit computation of reachable markings}
The team chooses the BFS to for the task. For convenience, we also implement a DFS function. But since the assignment requires implementing either BFS or DFS only, the
other approach is not shown here. The result of BFS is shown in Figure \ref{bfs}.
\begin{figure}[H]
    \centering
    \includegraphics[scale = 0.75]{picture/bfs.jpg}
    \caption{BFS approach result}
    \label{bfs}
\end{figure}

\subsection{Task 3 - Symbolic computation of reachable markings by using BDD}
The process begins by validating the Petri net structure, checking for zero places, and normalizing the dimensions 
of input/output matrices to handle inconsistencies. The initial marking $M_0$ is then encoded into a boolean formula, 
where the presence of a token represents a \code{true} state ($X[i]$) and its absence represents \code{false}.
The core logic involves constructing a global transition relation. For each transition, a \textbf{"guard"} condition is created 
to verify that input tokens exist and target output places are empty, strictly enforcing the 1-safe constraint. Simultaneously, 
an \textbf{"effect"} formula defines the next state ($X_p$) by handling token consumption and production, using XNOR operations 
to maintain the state of unaffected places. All valid transitions are combined into a single relation using the OR operator.
\begin{figure}[H]
    \centering
    \includegraphics[scale = 0.95]{picture/bddres.jpg}
    \caption{BDD result}
\end{figure}
Finally, the algorithm employs \textbf{fixed-point iteration} to compute the full state space. It repeatedly applies the transition 
relation, smoothes out current state variables, and renames next-state variables until the reachable set converges. The function returns 
a BDD representing the set of all reachable markings. 
\subsection{Task 4 - Deadlock detection by using ILP and BDD}
Task 4 is an algorithm to identify deadlocks — states where no transitions can fire — specifically within the context of the assignment.
The detection logic operates through a simulation and symbolic verification process:
\begin{itemize}
    \item \textbf{Sequential Traversal \& Loop Detection:} The algorithm simulates firing sequences while maintaining a \texttt{seen} set. This allows for the early detection and termination of infinite loops, preventing non-terminating recursion.
    \item \textbf{Validation:} When a state is reached where no transitions are enabled, the system cross-references this marking with the pre-computed Reachability BDD. A deadlock is confirmed only if the marking is a valid member of the reachable set.
\end{itemize}
\begin{figure}[H]
    \centering
    \includegraphics[scale = 0.9]{picture/dl.jpg}
    \caption{Deadlock detection result with the team source code}
\end{figure}
\subsection{Task 5 - Optimization over reachable markings}

Task 5 addresses the problem of optimizing a linear objective function by maximizing $c^T \cdot M$ over the set of reachable markings encoded 
in Binary Decision Diagrams (BDD).

The team implementation strategy focuses on handling symbolic data structures efficiently:
\begin{itemize}
    \item \textbf{Algorithm Logic:} The core function iterates through satisfying assignments derived from the BDD. It distinguishes between \textit{constrained variables} and \textit{free variables} (don't-care conditions), explicitly enumerating combinations of free variables to ensure the global maximum is found.
    \item \textbf{Edge Case Management:} The system robustly handles empty BDDs and tautologies (using a greedy approach for the latter) to return optimal results instantly.
\end{itemize}
\vspace{-20pt}
\begin{figure}[H]
    \centering
    \includegraphics[scale = 0.75]{picture/ilp.png}
    \caption{Integer linear programming result}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[scale = 1]{picture/benchmark.png}
    \caption{Task 5 different model testing result}
\end{figure}
\vspace{-40pt}
\subsection{Performance Comparison}
We observe a distinct performance trade-off governed by the size of the state space, based on the experimental results from Task 2 and Task 3. Specifically, BFS required approximately 
0.0004s, whereas the BDD approach took 0.046s. This represents a speedup of roughly 99.1\% in favor of the explicit approach for this specific dataset.
\begin{figure}[H]
    \centering
    \includegraphics[scale = 0.5]{picture/bfs_bdd_comp.jpg}
    \caption{Comparing result of BFS and BDD}
\end{figure}

\vspace{-20pt}
The primary cause for this discrepancy is the initialization overhead inherent to the Symbolic BDD engine (PyEDA). The process of setting up incurs a fixed cost. In small systems, this 
overhead outweighs the actual computation time. However, regarding space complexity, the Explicit method stores states as raw vectors with 
complexity $O(S \times P)$. In contrast, the BDD approach utilizes a directed acyclic graph (DAG) to compress the state space6. Therefore, while BFS is optimal for small 
nets (< 100 states), the Symbolic method is theoretically superior for complex systems (> 1000 states) where the "state space explosion" problem renders explicit storage unfeasible.

While the results are constant, execution time varies based on hardware specifications. CPU clock speed directly impacts \texttt{PyEDA} operations, and memory latency affects the 
combinatorial enumeration in Task 5. Additionally, for micro-scale operations, minor OS scheduling "noise" can cause negligible relative fluctuations.
\subsection{Challenges}
\begin{itemize}
    \item \textbf{Handling "Don't Care" Variables in Optimization (Task 5):}\code{PyEDA}'s function 
        \texttt{satisfy\_all()} method does not always return a complete marking vector, but a partial assignment where irrelevant variables are treated as "don't care" or free variables.
        Simply converting a partial assignment to a marking would lead to suboptimal results, as the objective function $c^T \cdot M$ might be maximized when these free variables are set to 1.
    \item \textbf{Infinite Loops in Deadlock Detection (Task 4):} The deadlock detection algorithm initially faced issues with non-terminating recursion 
    when the Petri net contained cycles (e.g., $P1 \to P2 \to P1$). Without a mechanism to track history, the sequential firing simulation would run 
    indefinitely without returning a result.
\end{itemize}
