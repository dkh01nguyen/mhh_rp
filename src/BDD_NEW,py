import collections
from typing import Tuple, List, Optional
from pyeda.inter import *
from .PetriNet import PetriNet
from collections import deque
import numpy as np
def bdd_reachable_counting(pn: PetriNet):
    """
    Tính toán tập trạng thái đạt được (Reachability Set) cho 1-safe Petri Net
    sử dụng BDD dựa trên thuật toán Symbolic PN Traversal.
    
    Ref: Pastor et al. "Symbolic Analysis of Bounded Petri Nets", IEEE Trans. Comput. 2001.
    """
    
    # 1. Xác định số lượng places và transitions
    # Theo PetriNet.py: Ma trận I và O có kích thước (Trans x Places)
    num_trans, num_places = pn.I.shape
    
    if num_places == 0:
        return None, 0

    # 2. Khởi tạo biến BDD
    # X: Biến trạng thái hiện tại (Current state variables)
    # Xp: Biến trạng thái kế tiếp (Next state variables - p')
    X = bddvars('x', num_places)
    Xp = bddvars('xp', num_places)

    # 3. Mã hóa trạng thái ban đầu (Initial Marking M0)
    # Theo section 3[cite: 305]: M0 được mã hóa thành tích logic của các biến
    M0_bdd = kwargs_to_bdd_marking(X, pn.M0)

    # 4. Xây dựng Transition Relations (R_t) cho từng transition
    # Ref: Section 4.3, Equation (6) và (442) trong bài báo
    # R_t(x, x') = E_t(x) * Product(x'_i == delta_i(x))
    trans_relations = []

    for t in range(num_trans):
        # a. Tính E_t (Enabling Condition) - Eq (3) 
        # Transition t enable khi tất cả input places đều có token (=1)
        E_t = 1
        
        # Xác định input places (p -> t) và output places (t -> p)
        # Lưu ý: pn.I[t, p] = 1 nghĩa là p là input của t
        inputs = [p for p in range(num_places) if pn.I[t, p] > 0]
        outputs = [p for p in range(num_places) if pn.O[t, p] > 0]
        
        for p_idx in inputs:
            E_t &= X[p_idx]
            
        # b. Tính hàm chuyển trạng thái (Next state function)
        # Ref: Eq (2) 
        # - Nếu p in input \ output: token bị xóa (x' = 0)
        # - Nếu p in output \ input: token được thêm (x' = 1)
        # - Nếu p in input & output (self-loop): giữ nguyên (x' = 1 thực ra là x' = x vì x=1 khi enable)
        # - Các place khác: giữ nguyên (x' = x)
        
        state_change = 1
        for p in range(num_places):
            is_input = p in inputs
            is_output = p in outputs
            
            if is_input and not is_output:
                # Token bị xóa -> trạng thái sau phải là 0
                state_change &= ~Xp[p]
            elif is_output and not is_input:
                # Token được sinh ra -> trạng thái sau phải là 1
                state_change &= Xp[p]
            elif is_input and is_output:
                # Self-loop -> trạng thái sau vẫn là 1 (giống trạng thái trước)
                state_change &= Xp[p]
            else:
                # Không liên quan -> Trạng thái giữ nguyên (x' <-> x)
                # Dùng toán tử XNOR (~(a ^ b)) hoặc tương đương (a & b) | (~a & ~b)
                state_change &= (Xp[p].equiv(X[p]))

        # R_t = Enabled AND NextStateLogic
        R_t = E_t & state_change
        trans_relations.append(R_t)

    # 5. Thuật toán Symbolic Traversal
    # Ref: Fig. 2 "Algorithm for symbolic PN traversal" [cite: 463, 474]
    
    Reached = M0_bdd  # Tập trạng thái đã đạt được
    From = M0_bdd     # Tập biên (frontier) để duyệt tiếp
    
    # Map dùng để đổi tên biến từ xp về x cho vòng lặp sau
    rename_map = {Xp[i]: X[i] for i in range(num_places)}
    
    while True:
        To = 0 # Tập rỗng (False)
        
        # Duyệt qua mọi transition để tìm trạng thái kế tiếp từ tập 'From'
        # Img(t, From) = Exists_x (R_t * From) 
        for t_idx, R_t in enumerate(trans_relations):
            if R_t.is_zero(): continue
            
            # Tính (R_t AND From)
            step1 = R_t & From
            
            if not step1.is_zero():
                # Existential Abstraction (Smoothing) trên biến hiện tại X
                # Để lấy tập trạng thái kế tiếp (trên biến Xp)
                img_xp = step1.smoothing(X)
                
                # Đổi tên biến Xp -> X để hợp nhất vào tập Reached
                img_x = img_xp.compose(rename_map)
                
                # Hợp vào tập đích 'To'
                To |= img_x
        
        # Tính tập trạng thái MỚI chưa từng thấy
        # New := To - Reached (tức là To AND NOT Reached) [cite: 468]
        New = To & ~Reached
        
        # Điều kiện dừng: Nếu không còn trạng thái mới nào (New == Empty)
        if New.is_zero():
            break
            
        # Cập nhật cho vòng lặp sau [cite: 469, 470]
        From = New
        Reached |= New

    # 6. Đếm số lượng markings
    # satisfy_count trả về số lượng tổ hợp biến thỏa mãn hàm BDD
    total_markings = Reached.satisfy_count()
    
    return Reached, total_markings

def kwargs_to_bdd_marking(X, marking_arr):
    """
    Helper chuyển mảng numpy marking thành biểu thức BDD.
    M[p]=1 -> X[p], M[p]=0 -> ~X[p]
    """
    expr = 1
    for i, val in enumerate(marking_arr):
        if val > 0:
            expr &= X[i]
        else:
            expr &= ~X[i]
    return expr